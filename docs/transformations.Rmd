---
title: "Transforming/Summarizing Data"
---

```{r setup, include = F}
source("setup.R")
```

This section will get you started with transforming and summarizing your data from raw read data to a variety of different data types which can be used to answer different questions.

Here we assume that you know how to [load/import](load.html) your data and that, if needed, you've cleaned up problematic `animal_id`s with the various [housekeeping](housekeeping.html) functions.

## Functions

In all cases you'll want to use the `visits()` function first, but after that it depends on what kinda of data you want to end up with.

1. [`visits()`](#visits) - Visits to a logger
2. [`move()`](#movements) - Movements between loggers
3. [`presence()`](#presence) - Presence around a logger
4. [`disp()`](#displacements) - Displacement from a logger
5. [`dom()`](#dominance) - Dominance matrices
6. [`activity()`](#activity) - Activity patterns
7. [`daily()`](#dailyactivity) - Daily activity patterns
8. [Working with multiple groups](#multi) - Applying transformations to different data groups simultaneously

Or click on the function name below to skip directly to the function tutorial:

```{r, echo = F, fig.align='center'}
DiagrammeR::grViz("
digraph order {

graph [overlap = true, compound = true]

node[shape = Mrecord]
edge[arrowhead = vee]

visits[label = 'visits()', URL = '#visits', tooltip = 'Individual logger visits']
disp[label = 'disp()', URL = '#displacements', tooltip = 'Displacements from the logger by another animal']
dom[label = 'dom()', URL = '#dominance', tooltip = 'Dominance indicated by displacements']
move[label = 'move()', URL = '#movements', tooltip = 'Movements between loggers']
presence[label = 'presence()', URL = '#presence', tooltip = 'presence bouts at loggers']
act[label = 'activity()', URL = '#acitivty', tooltip = 'Activity scored (active/inactive)']
daily[label = 'daily()', URL = '#dailyactivity', tooltip = 'Daily activity patterns']

visits-> {disp, move, presence}
presence -> act
disp -> dom
act -> daily

map1[label = 'map_ggmap()', URL = '#mapggmap', tooltip = 'Visualize with a static map']
map2[label = 'map_leaflet()', URL = '#mapleaflet', tooltip = 'Visualize with an interactive map']

{presence; move} -> {map1; map2}

}
", width = 500)
```
<a id = "visits"></a>

## `visits()`
This function is designed to turn 'raw' data into 'visits' data.

This is always the first function you should use. Raw read data contains an individual line of data for each read event made by the RFID logger.

For example, if the logger was set to record ids every ~3 seconds, an individual sitting on the logger for 13 seconds would look something like this:

```{r}
head(finches_lg)
```

The `visits()` function turns this raw data into something more practical:

```{r}
v <- visits(finches_lg, bw = 5)
head(v)
```

Note that the new data frame sorts the data differently from our raw data frame. We can look directly compare our raw data to our visit data for a particular individual by pulling out it's `animal_id`:

```{r}
head(finches_lg[finches_lg$animal_id == "06200004F8", ])
head(v[v$animal_id == "06200004F8", ])
```

You can also use `filter(v, animal_id == "06200004F8")` from the `dplyr` package or `subset(v, animal_id == "06200004F8")` which is built into R base.

Now we can see that the first series of raw reads have been combined into one visit, starting at 2015-09-11 16:59:06 and ending at 2015-09-11 17:00:32.

Visits are defined by:

- How much time has passed between reads (`bw`)
- A change in `animal_id` between two successive reads
- A change in `logger_id` between two successive reads (although generally this shouldn't be a defining point, because the `bw` should be smaller than the length of time it takes to move from one logger to another)

<a id = "visitsdata"></a>

### Data returned

The data returned by the visit function contains both new and old data:

- `animal_id` id of the animal making the visit
- `date` the date of the start of the visit
- `start` the time of the start of the visit
- `end` the time of the end of the visit
- `logger_id` the id of the logger being visited
- `animal_n` the number of unique `animal_id`s in the data set
- `logger_n` the number of unique `logger_id`s in the data set

Note that several of these new values could also have been obtained by hand:

```{r}
length(unique(v$animal_id))
length(unique(v$logger_id))
```

`species`, `sex`, `lon` and `lat` are all columns originally in the `finches_lg` dataset, they were automatically passed through the `visits()` function. Columns of extra data that are associated with either a `date`, an `animal_id`, or a `logger_id` will always be passed through unless `pass = FALSE`:

```{r}
visits(finches_lg, bw = 5, pass = FALSE)
```

### Specifying `bw`
Depending on the interval between reads in your RFID logger, you may have to adjust the value of `bw` which specifies how many seconds between reads separates two visits. The default is 3 seconds, but, as in our example here, that is too low for our data (which is why we specified `bw = 5`).

### Impossible and missing visits (`bw_imp`, `allow_imp`, and `na_rm`)
You should also be aware of 'impossible visits'. This may occur if the internal clocks on your RFIDs are not in sync, or if your loggers are very close to each other. An impossible visit is when an individual animal is detected at two different loggers within 2 seconds (the default) of each other. Unless your loggers are REALLY close to each other, this is highly unlikely.

Because both missing values (NAs) and impossible visits likely indicate a greater, underlying problem, you have to specifically tell the function to ignore them (or omit them, in the case of NAs).

```{r eval = FALSE}
v <- visits(finches_lg, allow_imp = TRUE, na_rm = TRUE)
```

You can define the minimum number of seconds needed to travel between loggers to specify which visits should be considered impossible. For example, if we say that it must take animals at least 3 minutes to travel between loggers, any visit made to a different logger within 3 minutes would be defined as 'impossible':

```{r, error = TRUE}
visits(finches_lg, bw_imp = 180)
```

### Summarizing visits
Visit data is the starting block of all other transformations, but you can also summarize and analyze visit data in itself.

For example, if we want to create daily summaries of the number of visits made and loggers used per `animal_id`, we could use the `dplyr` package (part of the [`tidyverse` family of packages](http://tidyverse.org/)).

Currently we have data on the total number of loggers in the data set, but what if we wanted to know how many loggers each individual used?

```{r}
library(dplyr)
visit_summary <- v %>%
  group_by(animal_id) %>%
  summarize(n_visits = length(start),
            n_loggers = length(unique(logger_id)),
            n_days = length(unique(date)),
            mean_visit_length = mean(as.numeric(difftime(end, start, units = "sec"))))
visit_summary
```

__A Side Note__  
This bit of code uses a slightly advanced technique called 'pipes': `%>%` These allow you to pass the output from one line directly down to the next line where it becomes the first (and hidden) argument. In this case, the first line specifies our visits data frame `v`, this then becomes the input for `group_by()`. The output of `group_by()` then becomes the input for `summarize()`. This makes your coding more efficient but may take a bit of getting used to.

You can find an indepth look at `dplyr`, pipes and related packages here: <http://r4ds.had.co.nz/transform.html>

For reference, you can achieve the same effect without pipes:

```{r}
library(dplyr)
visit_summary <- group_by(v, animal_id)
visit_summary <- summarize(visit_summary,
               n_visits = length(start),
               n_loggers = length(unique(logger_id)),
               n_days = length(unique(date)),
               mean_visit_length = mean(as.numeric(difftime(end, start, units = "sec"))))
visit_summary
```

The result is a data frame with one row for each `animal_id`, giving us information on how many loggers that animal has used, how many visits they have made, over how many days, and what the average visit length was.

If we wanted to plot this data, the package `ggplot2` is a great option:

```{r, fig.width = 6, fig.height = 3}
library(ggplot2)
ggplot(data = visit_summary, aes(x = animal_id, y = mean_visit_length)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + #rotate and shift id labels
  geom_bar(stat = "identity") + # Create bars
  labs(x = "Animal ID", y = "Average visit length (s)") # Make labels pretty

```

--------------------
Back to [top](#top) 
--------------------

<a id = "movements"></a>

## `move()`

This function is designed to turn 'Visit' data into 'Movement' data.

**Movements** are defined as trips between loggers (i.e. a event when a visit from one `animal_id` occurs at a different logger from the previous visit by that particular `animal_id`).

```{r}
v <- visits(finches_lg, bw = 5)
m <- move(v)
head(m)
```

### Data returned

This function returns a lot of information for each movement event. Note, in particular, that each movement event results in two rows of data: leaving and arriving

- `animal_id` id of the animal making the move
- `date` the date of the event (either arriving or leaving)
- `time` the time of the event (either arriving or leaving)
- `logger_id` the logger left or arrived at
- `direction` leaving or arriving
- `move_id` for each individual, a unique number tying the two events (leaving/arriving) of the movement together
- `move_dir` category indicating direction of the movement and the loggers involved
- `move_path` category indicating the loggers involved (no directionality)
- `strength` a metric indicating how 'easily' individuals move been loggers, it represents 1/time between loggers

`animal_n`, `logger_n`, `species`, `sex`, `lon`, and `lat` are extra columns passed through (see [visits data](#visitsdata) for more information).


### Including all individuals (`all = TRUE`)

In this case, four `animal_id` have been omitted because they never moved between loggers. While the id is retained in the _levels_ of the factor, `animal_id`, it is not present in the data frame:

```{r}
unique(m$animal_id)         # The animal_ids currently in the movement data
length(unique(m$animal_id)) # The number of animal_ids currently in the data
length(levels(m$animal_id)) # The number of levels of animal_id
```

However, if you wanted to retain all animals in the data set, regardless of whether they moved or not (for example, if you wanted to look at the likelihood of moving between loggers), you can specify that:

```{r}
m <- move(v, all = TRUE)

unique(m$animal_id)         # The animal_ids currently in the movement data
length(unique(m$animal_id)) # The number of animal_ids currently in the data
length(levels(m$animal_id)) # The number of levels of animal_id
```

Here we've told R that an additional parameter for `move()` is `all = TRUE`. animals which never visit more than one logger will have NA's in the data frame:

```{r}
m[is.na(m$direction), ]
```

### Summarizing movements

Once again we can summarize movement data using the `dplyr` package.

Are certain paths used more often?
```{r}
move_summary <- m %>%
  group_by(move_path, logger_id) %>%
  summarize(n = length(move_path))
move_summary
```
The NAs reflect the four individuals that did not move. 

Note that because there are two rows per movement event (leaving and arriving), we group by logger_id to summarize individually by logger (resulting in duplicate `n`s per `move_path`. This will acount for the 2 rows and keep logger ids in the final data frame (required for mapping later on).

However, if you only wanted `move_path` and `n`, you could simply omit `logger_id` and remove duplicates:
```{r}
move_summary %>% 
  select(-logger_id) %>%
  unique()
```

```{r, fig.width = 6}
ggplot(data = move_summary, aes(x = move_path, y = n)) +
  geom_bar(stat = "identity")
```

Are certain directions on particular paths used more often? (i.e. do birds go back and forth or do they circle around?)
```{r}

move_summary <- m %>%
  group_by(logger_id, move_path, move_dir) %>%
  summarize(n = length(move_path))
head(move_summary)
```

```{r, fig.width = 6}
ggplot(data = move_summary, aes(x = move_path, y = n, fill = move_dir)) +
  geom_bar(stat = "identity", position = "dodge", colour = "black")
```

Is there a relationship between use of a path and the average 'strength'?
```{r}

move_summary <- m %>%
  group_by(logger_id, move_path) %>%
  summarize(n = length(move_path),
            strength = mean(strength, na.rm = TRUE))
move_summary
```

```{r}
ggplot(data = move_summary, aes(x = strength, y = n)) +
  geom_point() +
  stat_smooth(method = "lm") # add a regression line w/ standard error
```

Do some animals move more than others?
```{r}
move_summary <- m %>%
  group_by(animal_id) %>%
  summarize(n = length(move_path[!is.na(move_path)])) # Number of movements omitting NAs
move_summary
```

Note that we have some zeros because we made sure to include all individuals in the analysis (`all = TRUE`, above) and because we specified `summarize()` to count only non-NA paths (`move_path[!is.na(move_path)]`).

```{r, fig.width = 6}
ggplot(data = move_summary, aes(x = animal_id, y = n)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + #rotate and shift id labels
  geom_bar(stat = "identity") 
```


--------------------
Back to [top](#top) 
--------------------

<a id = "presence"></a>

## `presence()`

This function is designed to turn 'Visit' data into 'Presence' data.

**Presence** reflects blocks of time in which an animal visited a given logger regularly. Essentially, presence is defined as a series of visits, and can overlap with presence of other animals (this differs from [visits](#visits), as normally one individual's visits cannot overlap with another). Presence near a logger ends when the individual moves to another logger or when a particular amount of time has passed without a visit (the time between visits, `bw`, 15 min by default).

```{r}
v <- visits(finches_lg, bw = 5)
p <- presence(v)
head(p)
```

### Data returned
- `animal_id` id of the animal present
- `date` the date of the start of the event
- `logger_id` the logger involved
- `start` the start time of the event
- `end` the end time of the event
- `length` the length of the event in minutes

`animal_n`, `logger_n`, `species`, `sex`, `lon`, and `lat` are extra columns passed through (see [visits data](#visitsdata) for more information).


### Specifying `bw`
The user of the function may define what the minimum amount of time between visits should be. Ground truthing could help establish the amount of time an individual spends near a logger without making a logger visit and could be used to determine this cutoff time. 

Note that the units for `bw` when defining [visits](#visits) is in seconds, while the units for `bw` when defining presence is in minutes. This reflects the different scales of the two functions.

```{r}
v <- visits(finches_lg, bw = 5)
p <- presence(v, bw = 20)  # Within 20 min
head(p)
```

```{r}
v <- visits(finches_lg, bw = 5)
p <- presence(v, bw = 90)  # Within 1.5 h
head(p)
```

The `bw` parameter can also be omitted entirely:
```{r}
v <- visits(finches_lg, bw = 5)
p <- presence(v, bw = NULL)
head(p)
```

When `bw = NULL` only a move to a different logger will initiate a new presence bout. Therefore this identifies how much time passes before a new logger is visited. The end time reflects the time of the final visit to that logger before moving to a new logger, but if an individual were to visit logger A all day on day 1 and disappear on day 2 and then make one visit to logger A on day 3 before moving immediately to logger B, that first bout of 'presence' would be considered two days long, whereas in reality, the individual did not make any visits on one of those days.

### Summarizing presence

What's the average time present for each individual?
```{r}
v <- visits(finches_lg, bw = 5)
p <- presence(v)

presence_summary <- p %>%
  group_by(animal_id) %>%
  summarize(n = length(start),          ## how many rows = number of events
            mean_length = mean(length)) ## mean length of events

presence_summary
```

Is there a relationship between the number and length of presence bouts?
```{r}
ggplot(data = presence_summary, aes(x = n, y = mean_length)) +
  geom_point()
```

Do animals spend more time around certain loggers?
```{r}
presence_summary <- p %>%
  group_by(logger_id) %>%
  summarize(n = length(start),
            mean_length = mean(length),
            se_length = sd(length)/sqrt(n))

presence_summary

ggplot(data = presence_summary, aes(x = logger_id, y = mean_length, fill = logger_id)) +
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = mean_length - se_length, 
                    ymax = mean_length + se_length), width = 0.25)
```
Note that there is only one bout of presence aroundlogger 2400, hence the lack of errorbars.
--------------------
Back to [top](#top) 
--------------------

<a id = "displacements"></a>

## `disp()`
This function is designed to turn 'visit' data into 'displacements' data.

__Displacements__ are events when one animal leaves the logger and is replaced by another animal within a certain, defined, time span.

In theory, we assume this is due to the arrival of a more dominant animal. Displacements events might therefore lead to information on relative dominance of different individuals (see [`dom()` function](#dominance)).

> __Disclaimer!__  
> It is important to ground-truth this assumption because, depending on species, displacements may not necessarily represent dominance. For example, in the case of black-capped chickadees, if the dominant male is using the logger, subsequent users of the logger may actually arrive and depart in descending order of rank. In this case, apparent 'displacements' are not displacements at all.

```{r}
v <- visits(finches_lg, bw = 5)
d <- disp(v)
names(d)
```

### Data returned
This function returns a list with three different types of displacement information: `displacements`, `summaries`, and `interactions`.

```{r}
head(d$displacements)
```

The `displacements` item is a data frame containing information on each displacement event

- `animal_id` id of an animal involved in a displacement event
- `date` the date of the start of the event
- `left` the time the 'displacee' left the logger
- `arrrived` the time the 'displacer' arrived at the logger
- `logger_id` the logger involved in the event
- `role` the role in the event of the current animal ('displacee' or 'displacer')

`animal_n`, `logger_n`, `species`, `sex`, `lon`, and `lat` are extra columns passed through (see [visits data](#visitsdata) for more information).


```{r}
head(d$summaries)
```

The `summaries` item is a data frame summarizing the displacement events for each individual

- `animal_id` id of animal
- `displacee` is the number of times the animal was the displacee
- `displacer` is the number of times the animal was the displacer
- `p_win` is the proportion of times the animal 'won' the interaction (i.e. number of displacer events divided by total interactions)

```{r}
head(d$interactions)
```

The `interactions` item is a data frame summarizing each potential interaction event. This is what's used to create a dominance matrix (see [`dom()` function](#dom) below):

- `displacer` is id of the animal doing the displacement
- `displacee` is id of the animal being displaced
- `n` is the number of times that particular combination of displacer and displacee was observed

### No events

If there are no displacement events in your data set, the function will stop. In this case, the data set is so small, there are no displacement events:

```{r, error = TRUE}
v <- visits(finches, bw = 5)
d <- disp(v)
```

### Specifying `bw`

The `disp()` function also contains a `bw` argument. In this case it reflects the maximum interval between the first animal leaving and the second animal arriving for an interaction to be considered a displacement:

```{r, error = TRUE}
v <- visits(finches_lg, bw = 5)
head(disp(v)$summaries)
head(disp(v, bw = 10)$summaries)
head(disp(v, bw = 15)$summaries)
```
However, an interval of 15s is pretty long and probably doesn't constitute a real displacement event.

### Summarizing displacements

Is one logger more contentious than others?

```{r}
disp_summary <- d$displacements %>%
  group_by(logger_id, role) %>%
  count() %>%
  filter(role == "displacer")

ggplot(data = disp_summary, aes(x = logger_id, y = n)) +
  geom_bar(stat = "identity")
```

What if we control for overall logger use?

```{r}
disp_summary <- d$displacements %>%
  group_by(logger_id, role) %>%
  count() %>%
  filter(role == "displacer")

presence_summary <- p %>%
  group_by(logger_id) %>%
  summarize(amount = sum(length))

full_summary <- full_join(disp_summary, presence_summary, by = "logger_id") %>%
  mutate(n = replace(n, is.na(n), 0),  # First replace the missing values of n with 0
         n_per_hour = n / amount * 60) # Calculate the number of interactions as an hourly rate

full_summary

ggplot(data = full_summary, aes(x = logger_id, y = n)) +
  geom_bar(stat = "identity")
```


```{r}
d$summaries

ggplot(data = d$summaries, aes(x = animal_id, y = p_win)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + #rotate and shift id labels
  geom_bar(stat = "identity") +
 # ylim(c(0, 1)) +
  labs(x = "Animal Id", y = "Proportion of 'wins'")
```

--------------------
Back to [top](#top) 
--------------------

<a id = "dominance"></a>

## `dom()`
This function is designed to turn 'Displacement' data into a 'Dominance matrix'.

A **Dominance matrix** is a matrix ranking individuals by wins and losses against other individuals. This matrix can be used to determine the final dominance hierarchy of a flock.

This function produces a dominance matrix which represents a 'best guess', as opposed to a perfect final product. The function attempts to find the best ordering, with the fewest reversals. A reversal is when an individual loses or wins more against one particular individual than expected given the general pattern of dominance wins/losses (i.e., a generally dominant individual that that has many losses against a generally subdomiant individual)

This matrix should not be considered a final product, but a starting point for manual manipulation.

```{r}
library(dplyr)

dm <- finches_lg %>%
  visits(bw = 5) %>%
  disp() %>%
  dom()
```

Note that this format is identical to:

```{r, eval = FALSE}
v <- visits(finches_lg, bw = 5)
d <- disp(v)
dm <- disp(d)
```

The pipe (`%>%`) takes the output of one line and passes it to the next (but does not create the intermediary objects).

```{r}
names(dm)
```


### Data returned
The first thing this function returns is some information on what happened when the dominance matrix was created:

```
animal_ids with fewer than 3 interactions have been omitted: 041868E9A8, 041869123C, 062000043E, 0620000513, 0620000514, 0620000520
```

This message is informing the user that several individuals have been omitted from the analysis because they contained fewer than 3 interactions each. This cutoff value can be customized (see `omit_cutoff` below).

```
Tried 1 times. Found 1 'best' matrix(ces), with 0 reversal(s) per matrix
```

The next message informs the user about the number of potential dominance matrices and the number of reversals per matrix. It is possible that several different dominance rankings can be obtained that are equally likely. In this case, `dom()` will return them all (`n 'best' matrix(ces)`). Furthermore, there may be one or more reversals per matrix.


Beyond these messages, the `dom()` function returns a list with three different types of information: `dominance`, `reversals`, and `matrices`.

```{r}
dm$dominance
```

The `dominance` item is a vector contain the dominance hierarchy for all animals listed from most to least dominant

```{r}
dm$reversals
```

### `tries`

### `omit_cutoff`

If the function finds more than one 'best guess' they will all be returned. 
In addition to the 'best guess' dominance matrices (`dm$matrices`), the function returns `dm$dominance` and `dm$reversals`

Let's work with a slightly larger data set but concentrate on one logger only:
```{r}
r <- dl_data(start = "2016-03-07", end = "2016-03-31")
r <- droplevels(r[r$logger_id == 2300, ])
```

The `r[r$logger_id == 2300, ]` results in a subset of the data frame `r` which only includes rows which have a `logger_id` equivalent to '2300'. The `droplevels()` function then drops all levels that don't appear in the data set (i.e. even though we've omitted certain individuals, the column `animal_id` keeps track of all _possible_ individuals). This is not important for the `disp()` function, but functions that work on individual data, such as `move()` and `presence()` rely on levels to keep track of ids. Using `droplevels()` when you want to completely omit individuals from analysis is therefore a good idea in general.

```{r}
v <- visits(r)
d <- disp(v)
dm <- dom(d$interactions)
names(dm)
```

The main part of this output are the matrices:

```{r}
dm$matrices
```

Here we have two, because both are equally possible. This is a situation in which a user will have to continue on by hand to end up with the best matrix.

Most dominant individuals are those to the left or the top.

These matrices are created by 

 - Ranking individuals based on their overall win rate
 - Attempting to fix 'reversals' by switching individuals around, and testing whether this reduced the total number of reversals or not.
 - After so many rounds of trying to reduce reversals, the script returns the best matrix

**Dominance Rankings** (`dm$dominance`) are the relative dominance rankings according to each final matrix (ranked from Dominant to Sub-dominant). 

```{r}
dm$dominance
```

Essentially, if the matrix is perfect, this is the dominance hierarchy you have in your flock. However, if you need to tweak your matrix, you'll come up with a different dominance hierarchy.

You can see that this matches the `animal_id` order in the matrices.

The final thing to consider are any remaining reversals.

**Reversals** are a table identifying remaining reversals: Pairs of individuals which could be switched either way in the hierarchy.
```{r}
dm$reversals
```

--------------------
Back to [top](#top) 
--------------------

<a id = "activity"></a>

## `activity()` [UNDERDEVELOPMENT]
This function scores individuals as either active or inactive based on their presence data. While simply looking at the presence bouts is a good proxy for active/inactive, scoring intervals as active/inactive allows for easier plotting as well as for averaging over days to create daily activity patterns (see [`daily()` function](#dailyactivity)).


First, let's restrict our analysis a bit:
```{r, eval = FALSE}
## FIXIx
library(plyr)
r <- chickadees[chickadees$experiment == "exp1",]
v <- visits(r)
f <- ddply(v, c("animal_id"), presence)
```

The default function calculates activity for each animal, independent of which loggers they are visiting, and with a resolution of 15min.

```{r, eval = FALSE}
## FIXIx
a <- ddply(f, c("animal_id"), activity)
```

Note that in addition to an activity data frame, this function also returns information regarding the process.

In this case, several individuals were skipped because they had data for less than 24 hrs. If you wish to include these individuals regardless, you can force their inclusion with:

```{r, eval = FALSE}
## FIXIx
a <- ddply(f, c("animal_id"), activity, keep_all = TRUE)
```

Note that now we are warned about:
- activity being low ("Active less than 5%...") 
- obs which are shorter than the resolution 'res'
- several individual with presence bouts all 0min (this happens when each presence bout is the result of a single visit)

These messages are presented to help you understand the quality of your activity data.

For example, if the length of most observations (presence bouts) are less than the resolution, there's a good chance that many observations are being missed when scoring activity. We can fix this by adjusting the resolution. In general, a small resolution is always better. Note, however, that the smaller the resolution, the more computationally challenging.

Let's use a resolution of 1 minute:

```{r, eval = FALSE}
## FIXIx
a <- ddply(f, c("animal_id"), activity, keep_all = TRUE, res = 1)
```

The number of messages has definitely done down but we still have quite a few. Most of these messages are warnings about the lack of data, so let's go back to omitting individuals with low data:

```{r, eval = FALSE}
## FIXIx
a <- ddply(f, c("animal_id"), activity, res = 1)
```

We still have one animal (0700EE0E42) with a warning about a low resolution, but this is most likely due to the fact that there are very short presence bouts (Median obs is 0 min).

Several individuals are active for less than 5% of the total time, but this isn't necessarily a problem.

Next let's take a look at our data:

```{r, eval = FALSE}
## FIXIx
head(a)
summary(a)
```

Our extra data (experiment, lat, lon) is all there, but many of the lat/lons are "NA" now. This is because the default for the activity() function is to calculate activity independent of logger. However if an individual has visited only one logger, all the extra data associated with that logger will be preserved.

Let's plot one day for one individual:
```{r, fig.width = 6, eval = FALSE}
#FIX
library(ggplot2)

i <- a[a$animal_id == "0620000525" & a$date == as.POSIXct("2015-12-06"),]

ggplot(data = i, aes(x = time, ymin = 0, ymax = activity)) +
  geom_ribbon()
```

There's a clear daily pattern, but it's a bit hard to tell without sunrise and sunset:

--------------------
Back to [top](#top) 
--------------------

<a id = "dailyactivity"></a>

## `daily()` [UNDERDEVELOPMENT]




--------------------------
Back to [top](#top)  
Go back to [home](index.html) | Go back to [housekeeping](housekeeping.html) | Continue with [visualizations](maps.html)
